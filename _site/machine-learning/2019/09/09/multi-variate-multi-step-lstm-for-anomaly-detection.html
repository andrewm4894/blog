<p>This post will walk through a synthetic example illustrating one way to use a multi-variate, multi-step <a href="https://en.wikipedia.org/wiki/Long_short-term_memory">LSTM</a> for anomaly detection.</p>

<p>Imagine you have a matrix ofÂ <strong>k time series</strong>Â data coming at you at regular intervals and you look at the lastÂ <strong>n observations</strong>Â for each metric.</p>

<figure>

![](/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_KJE0RC7793B8qPLWadDqVg.png)

<figcaption>

A matrix of 5 metrics from period t to t-n

</figcaption>

</figure>

<p>One approach to doing anomaly detection in such a setting is to build a model to predict each metric over each time step in your forecast horizon and when you notice your prediction errors start to change significantly this can be a sign of some anomalies in your incoming data.</p>

<p>This is essentially an unsupervised problem that can be converted into a supervised one. You train the model to predict its own training data. Then once it gets good at this (assuming your training data is relatively typical of normal behavior of your data), if you see some new data for which your prediction error is much higher then expected, that can be a sign that you new data is anomalous in some way.</p>

<p><em>Note: This example is adapted and built off of</em>Â <a href="https://developer.ibm.com/tutorials/iot-deep-learning-anomaly-detection-5/"><em>this tutorial</em></a>Â <em>which i found a very useful starting point. All the code for this post is in</em>Â <a href="https://github.com/andrewm4894/keras_learn/blob/master/lstm_multi.ipynb"><em>this notebook</em></a><em>. The rest of this post will essentially walk though the code.</em></p>

<h2 id="imports--paramaters">Imports &amp; Paramaters</h2>

<p>Below shows the imports and all the parameters for this example, you should be able to play with them and see what different results you get.</p>

<p><em>Note: There is a</em>Â <a href="https://github.com/andrewm4894/keras_learn/blob/master/Pipfile"><em>Pipfile here</em></a>Â <em>that shows the Python libraries needed. If you are not familiar, you should really check out</em>Â <a href="https://pipenv.readthedocs.io/en/latest/basics/https://pipenv.readthedocs.io/en/latest/basics/"><em>pipenv</em></a><em>, its really useful once you play with it a bit.</em></p>

<p>https://gist.github.com/andrewm4894/4540e23d86fa02859191a38998661849#file-keras_lstm_multi_imports_and_params-py</p>

<h2 id="fake-data">Fake Data!</h2>

<p>We will generate some random data, and then smooth it out to look realistic. This will be ourÂ <strong>â€˜normalâ€™ data</strong>Â that we will use to train the model.</p>

<figure>

![](/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_HyFQhws3uVNRxYN6jBIzCw.jpeg)

<figcaption>

I couldn't help myself.

</figcaption>

</figure>

<p>Then we will make a copy of this normal data and inject in some random noise at a certain point and for a period of time. This will be ourÂ <strong>â€˜brokenâ€™ data</strong>.</p>

<p>So this â€˜brokenâ€™ data is the data that we should see the model struggle with in terms of prediction error. Itâ€™s this error (aggregated and summarized in some way, e.g. turned into a z-score) that you could then use to drive an anomaly score (you could also use loss from the continually re-training on new data whereby the training loss should initially spike once the broken data comes into the system but over time the training would then adapt the model to the new data).</p>

<p>https://gist.github.com/andrewm4894/417f54744ccf1e8a909c9e373abd21fd#file-keras_lstm_multi_generate_fake_data_normal-py</p>

<p>This gives us our normal-ish real word looking data that we will use to train the model.</p>

<figure>

![](/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_pJdOGJ3WMJy1qCcqbr6Rww.jpeg)

<figcaption>

5 random time series that have been smoothed a bit to look realistic.

</figcaption>

</figure>

<p>To make our â€˜brokenâ€™ data (called data_new in the code) i lazily just copy the â€˜normalâ€™ data but mess up a segment of it with some random noise.</p>

<p>https://gist.github.com/andrewm4894/62174bbf299ecb36cada254314290644#file-keras_lstm_multi_generate_fake_data_broken-py</p>

<p>And so below we can see our â€˜brokenâ€™ data. Iâ€™ve set the broken segment to be quite wide here and its very obvious the broken data is totally different. The hope is that in reality the model once trained would be good at picking up much more nuanced changes in the data that are less obvious to the human eye.</p>

<p>For example if all metrics were to suddenly become more or less correlated than normal but all still each move by a typical amount individually then this is the sort of change youâ€™d like the model to highlight (this is probably something i should have tried to do when making the â€˜brokenâ€™ data to make the whole example more realistic, feel free to try this yourself and let me know how you get on).</p>

<figure>

![](/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_UKqQRjsqMTPrRcpB7uEQbg.jpeg)

<figcaption>

Same as the â€œnormalâ€ data but iâ€™ve messed up a huge chunk of it.

</figcaption>

</figure>

<h2 id="some-helper-functions">Some Helper Functions</h2>

<p>Iâ€™ve built some helper functions to make life easier in the example notebook. Iâ€™ll share the code below and talk a little about each.</p>

<ul>
  <li><strong>data_reshape_for_model()</strong>Â : This function basically takes in an typical dataframe type array, loops through that data and reshapes it all into a numpy array of the shape expected by the keras LSTM model for both training and prediction. Figuring out how to reshape the data based on the N_TIMESTEPS, N_FEATURES and length of the data was actually probably the trickiest part of this whole example. Iâ€™ve noticed that many tutorials online just reshape the data but do so in an incomplete way by essentially just pairing off rows. But what you really want to do is step through all the rows to make sure you roll your N_TIMESTEPS window properly over the data to as to all possible windows in your training.</li>
  <li><strong>train()</strong>Â : This is just a simple wrapper for the keras train function. There is no real need for it.</li>
  <li><strong>predict()</strong>Â : Similar to train() is just a wrapper function that does not really do much.</li>
  <li><strong>model_data_to_df_long()</strong>Â : This function takes in a data array as used by the keras model and unrolls it into one big long pandas dataframe (numpy arrays freak me out a bit sometimes so i always try fall back pandas when i can get away with it ğŸ˜‰).</li>
  <li><strong>model_df_long_to_wide()</strong>Â : This function then takes the long format dataframe created by model_data_to_df_long() and converts it into a wide format that is closed to the original dataset of one row one observation and one column for each input feature (plus lots more columns for predictions for each feature for each timestep).</li>
  <li><strong>df_out_add_errors()</strong>Â : This function adds errors and error aggregation columns to the main df_out dataframe which stores all the predictions and errors for each original row of data.</li>
  <li><strong>yhat_to_df_out()</strong>Â : This function takeâ€™s in the model formatted training data and model formatted prediction outputs and wraps all the above functions to make a nice little â€œdf_outâ€ dataframe that has everything we want in it and is one row one observation so lines up more naturally with the original data.</li>
</ul>

<p>https://gist.github.com/andrewm4894/58179c6e240163a45dc2acff1843f7f2#file-keras_lstm_multi_helper_functions-py</p>

<h2 id="build--train-the-model">Build &amp; Train The Model</h2>

<p>Below code builds the model, trains it and also calls predict on all the training data be able to get errors on the original â€˜normalâ€™ training data.</p>

<p>https://gist.github.com/andrewm4894/48fa72cf730eead43f3ce54cdb3842cb#file-keras_lstm_multi_build_and_train-py</p>

<p>We then call our â€œdo everythingâ€ yhat_to_df_out() function on the training data and the predictions from the model.</p>

<p>https://gist.github.com/andrewm4894/9b8c108661fc640325f6be774a0a1861#file-keras_lstm_multi_make_df_out-py</p>

<p>Now we can plot lots of things from df_out. For example here are the errors averaged across all five features are each timestep prediction horizon.</p>

<p>https://gist.github.com/andrewm4894/50bf96cc87ac37079c55516f4068a4b6#file-keras_lstm_multi_plot_error_avg-py</p>

<p><img src="/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_6HBimTV7Bete2b2_iB9gTw.jpeg" alt="" /></p>

<p>In the above plot we can see the averaged error of the model on its training data. Each line represents a different forecast horizon. We can see that the lines are sort of â€˜stackedâ€™ on top of each other which makes sense as youâ€™d generally expect the error 5 timesteps out (red line â€œt4_error_avgâ€) to be higher then the one step ahead forecast (greeny/orangy line â€œt0_error_avgâ€).</p>

<p>If we look at the standard deviation of our errors in a similar way, we can see how the standard deviation of our errors generally tends to increase at times when our 5 original features are diverging from each other as you can imagine these are the hardest parts of our time series for this model to predict.</p>

<p><img src="/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_PuMxLqfI3xQkoTzNo44v1g.jpeg" alt="" /></p>

<h2 id="lets-break-it">Lets Break It</h2>

<p>So now that we have our model trained on our â€˜normalâ€™ data we can use it to see how well it does at predicting our new â€˜brokenâ€™ data.</p>

<p>https://gist.github.com/andrewm4894/fdb8ac2b8e8624e2a13e84b399f0faa1#file-keras_lstm_multi_build_and_train_new_broken_data-py</p>

<figure>

![](/assets/images/2019-09-09-multi-variate-multi-step-lstm-for-anomaly-detection/1_qB4T52kMb6VdRHsKT4gXbw.jpeg)

<figcaption>

Here we can see that as soon as we hit the broken data the prediction errors go through the roof.

</figcaption>

</figure>

<p>From the above we can see that as soon as the random broken data comes into the time series the model prediction errors explode.</p>

<p>As mentioned, this is a very obvious and synthetic use case just for learning on but the main idea is that if your data changed in a more complicated and harder to spot way then your error rates would everywhere reflect this change. These error rates could then be used as input into a more global anomaly score for your system.</p>

<p>Thatâ€™s it, thanks for reading and feel free to add any comments or questions below. I may add some more complicated or real world examples building on this approach at a later stage.</p>

<p><strong>UPDATE</strong>:Â <a href="https://colab.research.google.com/drive/1Mx2uoeGL3VRQLifNtrcPY0rABc1GY3ep">Here</a>Â is a Google Colab notebook thatâ€™s a bit better as iâ€™ve worked a bit more on this since the original blog post.</p>
